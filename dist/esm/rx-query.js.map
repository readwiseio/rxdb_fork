{"version":3,"file":"rx-query.js","names":["BehaviorSubject","firstValueFrom","merge","mergeMap","filter","map","startWith","distinctUntilChanged","shareReplay","appendToArray","areRxDocumentArraysEqual","now","overwriteGetterForCaching","pluginMissing","PROMISE_RESOLVE_FALSE","RX_META_LWT_MINIMUM","RXJS_SHARE_REPLAY_DEFAULTS","sortObject","newRxError","runPluginHooks","calculateNewResults","triggerCacheReplacement","getQueryMatcher","getSortComparator","normalizeMangoQuery","runQueryUpdateFunction","selectorIncludesDeleted","RxQuerySingleResult","getQueryPlan","ensureNotFalsy","getChangedDocumentsSince","_queryCount","newQueryID","RESTORE_QUERY_UPDATE_DRIFT","RESTORE_QUERY_MAX_DOCS_CHANGED","RESTORE_QUERY_MAX_TIME_AGO","RxQueryBase","op","mangoQuery","collection","other","id","_execOverDatabaseCount","_creationTime","_lastEnsureEqual","uncached","refCount$","_result","_latestChangeEvent","_lastExecStart","_lastExecEnd","_limitBufferSize","_limitBufferResults","_persistentQueryCacheResult","undefined","_persistentQueryCacheResultLwt","_ensureEqualQueue","_getDefaultQuery","isFindOneByIdQuery","schema","primaryPath","_proto","prototype","_setResultData","newResultData","Map","Array","from","values","docsDataMap","docsMap","docs","docData","_docCache","getCachedRxDocument","docsData","doc","set","primary","_data","length","_execOverDatabase","preparedQuery","getPreparedQuery","result","storageInstance","count","mode","database","allowSlowCount","queryObj","ids","selector","$in","ret","mustBeQueried","forEach","getLatestDocumentDataIfExists","_deleted","push","findDocumentsById","docsPromise","queryCollection","then","exec","throwIfMissing","name","query","_ensureEqual","$","toString","stringObj","value","JSON","stringify","persistentQueryId","String","hashFunction","hookInput","rxQuery","jsonSchema","includesDeleted","$eq","index","unshift","limit","prepareQuery","doesDocumentDataMatch","queryMatcher","remove","isArray","Promise","all","incrementalRemove","asRxQuery","update","_updateObj","patch","incrementalPatch","modify","mutationFunction","incrementalModify","where","_queryObj","sort","_params","skip","_amount","enableLimitBuffer","bufferSize","console","error","enablePersistentQueryCache","backend","_persistentQueryCacheBackend","_persistentQueryCacheLoaded","_restoreQueryCacheFromPersistedState","getItem","log","persistedQueryCacheIds","Set","limitBufferIds","startsWith","add","replace","time","lwt","Number","documents","changedDocs","Math","floor","changedDocIds","d","docIdsWeNeedToFetch","has","otherPotentialMatchingDocs","_queryCollectionByIds","concat","normalizedMangoQuery","sortComparator","Infinity","lastValidIndex","findLastIndex","slice","unchangedItemsMayNowBeInResults","size","pastLimitItems","finalResults","_changeEventBuffer","counter","timeEnd","_createClass","key","get","_$","results$","pipe","changeEvent","isLocal","prev","curr","useResult","reactivity","getReactivityFactory","fromObservable","normalizedQuery","tunnelQueryCache","_queryCache","getByQuery","createRxQuery","_isResultsInSync","currentLatestEventNumber","getCounter","destroyed","__ensureEqual","mustReExec","missedChangeEvents","getFrom","runChangeEvents","reduceByLastOfDoc","_loop","cE","find","documentId","previousCount","newCount","didMatchBefore","previousDocumentData","doesMatchNow","documentData","eventReduceResult","runFullQueryAgain","changed","newResults","returnValue","updatePersistentQueryCache","docsKeys","idsToPersist","setItem","docResults","docIds","docId","Object","mutateableQuery","queryPlan","docsFromStorage","fromStorageList","queryResult","splice","keys","r","isRxQuery","obj"],"sources":["../../src/rx-query.ts"],"sourcesContent":["import {\n    BehaviorSubject,\n    firstValueFrom,\n    Observable,\n    merge\n} from 'rxjs';\nimport {\n    mergeMap,\n    filter,\n    map,\n    startWith,\n    distinctUntilChanged,\n    shareReplay\n} from 'rxjs/operators';\nimport {\n    appendToArray,\n    areRxDocumentArraysEqual,\n    now,\n    overwriteGetterForCaching,\n    pluginMissing,\n    PROMISE_RESOLVE_FALSE, RX_META_LWT_MINIMUM,\n    RXJS_SHARE_REPLAY_DEFAULTS,\n    sortObject\n} from './plugins/utils/index.ts';\nimport {\n    newRxError\n} from './rx-error.ts';\nimport {\n    runPluginHooks\n} from './hooks.ts';\nimport type {\n    MangoQuery,\n    PreparedQuery,\n    QueryMatcher,\n    RxChangeEvent,\n    RxCollection,\n    RxDocument,\n    RxDocumentData,\n    RxJsonSchema,\n    FilledMangoQuery,\n    ModifyFunction,\n    RxDocumentWriteData,\n    RxQuery,\n    RxQueryOP, MangoQuerySelector, MangoQuerySortPart\n} from './types/index.d.ts';\nimport { calculateNewResults } from './event-reduce.ts';\nimport { triggerCacheReplacement } from './query-cache.ts';\nimport {\n    getQueryMatcher,\n    getSortComparator,\n    normalizeMangoQuery,\n    runQueryUpdateFunction,\n    selectorIncludesDeleted\n\n} from './rx-query-helper.ts';\nimport { RxQuerySingleResult } from './rx-query-single-result.ts';\nimport { getQueryPlan } from './query-planner.ts';\nimport { ensureNotFalsy } from 'event-reduce-js';\nimport { getChangedDocumentsSince } from './rx-storage-helper.ts';\n\n\nexport interface QueryCacheBackend {\n    getItem<T extends string | string[]>(key: string): Promise<T | null>;\n    setItem<T extends string | string[]>(key: string, value: T): Promise<T>;\n}\n\nlet _queryCount = 0;\nconst newQueryID = function (): number {\n    return ++_queryCount;\n};\n\n// allow changes to be 100ms older than the actual lwt value\nconst RESTORE_QUERY_UPDATE_DRIFT = 100;\n\n// 5000 seems like a sane number where re-executing the query will be easier than trying to restore\nconst RESTORE_QUERY_MAX_DOCS_CHANGED = 5000;\n\n// If a query was persisted more than a week ago, just re-execute it\nexport const RESTORE_QUERY_MAX_TIME_AGO = 7 * 24 * 60 * 60 * 1000;\n\nexport class RxQueryBase<\n    RxDocType,\n    RxQueryResult,\n    OrmMethods = {},\n    Reactivity = unknown,\n> {\n\n    public id: number = newQueryID();\n\n    /**\n     * Some stats then are used for debugging and cache replacement policies\n     */\n    public _execOverDatabaseCount: number = 0;\n    public _creationTime = now();\n\n    // used in the query-cache to determine if the RxQuery can be cleaned up.\n    public _lastEnsureEqual = 0;\n\n    public uncached = false;\n\n    // used to count the subscribers to the query\n    public refCount$ = new BehaviorSubject(null);\n\n    public isFindOneByIdQuery: false | string | string[];\n\n\n    /**\n     * Contains the current result state\n     * or null if query has not run yet.\n     */\n    public _result: RxQuerySingleResult<RxDocType> | null = null;\n\n\n    constructor(\n        public op: RxQueryOP,\n        public mangoQuery: Readonly<MangoQuery<RxDocType>>,\n        public collection: RxCollection<RxDocType>,\n        // used by some plugins\n        public other: any = {}\n    ) {\n        if (!mangoQuery) {\n            this.mangoQuery = _getDefaultQuery();\n        }\n\n        this.isFindOneByIdQuery = isFindOneByIdQuery(\n            this.collection.schema.primaryPath as string,\n            mangoQuery\n        );\n    }\n    get $(): BehaviorSubject<RxQueryResult> {\n        if (!this._$) {\n\n            const results$ = this.collection.$.pipe(\n                /**\n                 * Performance shortcut.\n                 * Changes to local documents are not relevant for the query.\n                 */\n                filter(changeEvent => !changeEvent.isLocal),\n                /**\n                 * Start once to ensure the querying also starts\n                 * when there where no changes.\n                 */\n                startWith(null),\n                // ensure query results are up to date.\n                mergeMap(() => _ensureEqual(this as any)),\n                // use the current result set, written by _ensureEqual().\n                map(() => this._result),\n                // do not run stuff above for each new subscriber, only once.\n                shareReplay(RXJS_SHARE_REPLAY_DEFAULTS),\n                // do not proceed if result set has not changed.\n                distinctUntilChanged((prev, curr) => {\n                    if (prev && prev.time === ensureNotFalsy(curr).time) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }),\n                filter(result => !!result),\n                /**\n                 * Map the result set to a single RxDocument or an array,\n                 * depending on query type\n                 */\n                map((result) => {\n                    const useResult = ensureNotFalsy(result);\n                    if (this.op === 'count') {\n                        return useResult.count;\n                    } else if (this.op === 'findOne') {\n                        // findOne()-queries emit RxDocument or null\n                        return useResult.documents.length === 0 ? null : useResult.documents[0];\n                    } else if (this.op === 'findByIds') {\n                        return useResult.docsMap;\n                    } else {\n                        // find()-queries emit RxDocument[]\n                        // Flat copy the array so it won't matter if the user modifies it.\n                        return useResult.documents.slice(0);\n                    }\n                })\n            );\n\n            this._$ = merge<any>(\n                results$,\n                /**\n                 * Also add the refCount$ to the query observable\n                 * to allow us to count the amount of subscribers.\n                 */\n                this.refCount$.pipe(\n                    filter(() => false)\n                )\n            );\n        }\n        return this._$ as any;\n    }\n\n    get $$(): Reactivity {\n        const reactivity = this.collection.database.getReactivityFactory();\n        return reactivity.fromObservable(\n            this.$,\n            undefined,\n            this.collection.database\n        ) as any;\n    }\n\n    get includesDeleted(): boolean {\n        return selectorIncludesDeleted(this.mangoQuery.selector);\n    }\n\n    // stores the changeEvent-number of the last handled change-event\n    public _latestChangeEvent: -1 | number = -1;\n\n    // time stamps on when the last full exec over the database has run\n    // used to properly handle events that happen while the find-query is running\n    public _lastExecStart: number = 0;\n    public _lastExecEnd: number = 0;\n\n    // Fields used for the Limit Buffer when enabled:\n    public _limitBufferSize: number | null = null;\n    public _limitBufferResults: RxDocumentData<RxDocType>[] | null = null;\n\n    // Fields used for the persistent query cache when enabled:\n    public _persistentQueryCacheResult?: string[] | string = undefined;\n    public _persistentQueryCacheResultLwt?: string = undefined; // lwt = latest write time\n    public _persistentQueryCacheLoaded?: Promise<void>;\n    public _persistentQueryCacheBackend?: QueryCacheBackend;\n\n    /**\n     * ensures that the exec-runs\n     * are not run in parallel\n     */\n    public _ensureEqualQueue: Promise<boolean> = PROMISE_RESOLVE_FALSE;\n\n    /**\n     * Returns an observable that emits the results\n     * This should behave like an rxjs-BehaviorSubject which means:\n     * - Emit the current result-set on subscribe\n     * - Emit the new result-set when an RxChangeEvent comes in\n     * - Do not emit anything before the first result-set was created (no null)\n     */\n    public _$?: Observable<RxQueryResult>;\n\n    /**\n     * set the new result-data as result-docs of the query\n     * @param newResultData json-docs that were received from the storage\n     */\n    _setResultData(newResultData: RxDocumentData<RxDocType>[] | number | Map<string, RxDocumentData<RxDocType>>): void {\n        if (typeof newResultData === 'number') {\n            this._result = new RxQuerySingleResult<RxDocType>(\n                this.collection,\n                [],\n                newResultData\n            );\n            return;\n        } else if (newResultData instanceof Map) {\n            newResultData = Array.from((newResultData as Map<string, RxDocumentData<RxDocType>>).values());\n        }\n\n        const docsDataMap = new Map();\n        const docsMap = new Map();\n\n\n        const docs = newResultData.map(docData => this.collection._docCache.getCachedRxDocument(docData));\n\n        /**\n         * Instead of using the newResultData in the result cache,\n         * we directly use the objects that are stored in the RxDocument\n         * to ensure we do not store the same data twice and fill up the memory.\n         */\n        const docsData = docs.map(doc => {\n            docsDataMap.set(doc.primary, doc._data);\n            docsMap.set(doc.primary, doc);\n            return doc._data;\n        });\n\n        this._result = new RxQuerySingleResult(this.collection, docsData, docsData.length);\n    }\n\n    /**\n     * executes the query on the database\n     * @return results-array with document-data\n     */\n    async _execOverDatabase(): Promise<RxDocumentData<RxDocType>[] | number> {\n        this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n        this._lastExecStart = now();\n\n\n        if (this.op === 'count') {\n            const preparedQuery = this.getPreparedQuery();\n            const result = await this.collection.storageInstance.count(preparedQuery);\n            if (result.mode === 'slow' && !this.collection.database.allowSlowCount) {\n                throw newRxError('QU14', {\n                    collection: this.collection,\n                    queryObj: this.mangoQuery\n                });\n            } else {\n                return result.count;\n            }\n        }\n\n        if (this.op === 'findByIds') {\n            const ids: string[] = ensureNotFalsy(this.mangoQuery.selector as any)[this.collection.schema.primaryPath].$in;\n            const ret = new Map<string, RxDocument<RxDocType>>();\n            const mustBeQueried: string[] = [];\n            // first try to fill from docCache\n            ids.forEach(id => {\n                const docData = this.collection._docCache.getLatestDocumentDataIfExists(id);\n                if (docData) {\n                    if (!docData._deleted) {\n                        const doc = this.collection._docCache.getCachedRxDocument(docData);\n                        ret.set(id, doc);\n                    }\n                } else {\n                    mustBeQueried.push(id);\n                }\n            });\n            // everything which was not in docCache must be fetched from the storage\n            if (mustBeQueried.length > 0) {\n                const docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);\n                docs.forEach(docData => {\n                    const doc = this.collection._docCache.getCachedRxDocument(docData);\n                    ret.set(doc.primary, doc);\n                });\n            }\n            return ret as any;\n        }\n\n\n        const docsPromise = queryCollection<RxDocType>(this as any);\n        return docsPromise.then(docs => {\n            this._lastExecEnd = now();\n            return docs;\n        });\n    }\n\n    /**\n     * Execute the query\n     * To have an easier implementations,\n     * just subscribe and use the first result\n     */\n    public exec(throwIfMissing: true): Promise<RxDocument<RxDocType, OrmMethods, Reactivity>>;\n    public exec(): Promise<RxQueryResult>;\n    public exec(throwIfMissing?: boolean): Promise<any> {\n        if (throwIfMissing && this.op !== 'findOne') {\n            throw newRxError('QU9', {\n                collection: this.collection.name,\n                query: this.mangoQuery,\n                op: this.op\n            });\n        }\n\n\n        /**\n         * run _ensureEqual() here,\n         * this will make sure that errors in the query which throw inside of the RxStorage,\n         * will be thrown at this execution context and not in the background.\n         */\n        return _ensureEqual(this as any)\n            .then(() => firstValueFrom(this.$))\n            .then(result => {\n                if (!result && throwIfMissing) {\n                    throw newRxError('QU10', {\n                        collection: this.collection.name,\n                        query: this.mangoQuery,\n                        op: this.op\n                    });\n                } else {\n                    return result;\n                }\n            });\n    }\n\n\n\n    /**\n     * cached call to get the queryMatcher\n     * @overwrites itself with the actual value\n     */\n    get queryMatcher(): QueryMatcher<RxDocumentWriteData<RxDocType>> {\n        const schema = this.collection.schema.jsonSchema;\n        const normalizedQuery = normalizeMangoQuery(\n            this.collection.schema.jsonSchema,\n            this.mangoQuery\n        );\n        return overwriteGetterForCaching(\n            this,\n            'queryMatcher',\n            getQueryMatcher(\n                schema,\n                normalizedQuery\n            ) as any\n        );\n    }\n\n    /**\n     * returns a string that is used for equal-comparisons\n     * @overwrites itself with the actual value\n     */\n    toString(): string {\n        const stringObj = sortObject({\n            op: this.op,\n            query: this.mangoQuery,\n            other: this.other\n        }, true);\n        const value = JSON.stringify(stringObj);\n        this.toString = () => value;\n        return value;\n    }\n\n    persistentQueryId() {\n        return String(this.collection.database.hashFunction(this.toString()));\n    }\n\n    /**\n     * returns the prepared query\n     * which can be send to the storage instance to query for documents.\n     * @overwrites itself with the actual value.\n     */\n    getPreparedQuery(): PreparedQuery<RxDocType> {\n        const hookInput = {\n            rxQuery: this,\n            // can be mutated by the hooks so we have to deep clone first.\n            mangoQuery: normalizeMangoQuery<RxDocType>(\n                this.collection.schema.jsonSchema,\n                this.mangoQuery\n            )\n        };\n\n        // Set _deleted to false if not explicitly set in selector\n        if (!this.includesDeleted) {\n            hookInput.mangoQuery.selector = {\n                ...hookInput.mangoQuery.selector,\n                _deleted: { $eq: false },\n            };\n        }\n\n        if (hookInput.mangoQuery.index) {\n            hookInput.mangoQuery.index.unshift('_deleted');\n        }\n\n        if (this._limitBufferSize !== null && hookInput.mangoQuery.limit) {\n            hookInput.mangoQuery.limit = hookInput.mangoQuery.limit + this._limitBufferSize;\n        }\n\n        runPluginHooks('prePrepareQuery', hookInput);\n\n        const value = prepareQuery(\n            this.collection.schema.jsonSchema,\n            hookInput.mangoQuery as any\n        );\n\n        this.getPreparedQuery = () => value;\n        return value;\n    }\n\n    /**\n     * returns true if the document matches the query,\n     * does not use the 'skip' and 'limit'\n     */\n    doesDocumentDataMatch(docData: RxDocType | any): boolean {\n        // if doc is deleted, it cannot match\n        if (docData._deleted) {\n            return false;\n        }\n\n        return this.queryMatcher(docData);\n    }\n\n    /**\n     * deletes all found documents\n     * @return promise with deleted documents\n     */\n    remove(): Promise<RxQueryResult> {\n        return this\n            .exec()\n            .then(docs => {\n                if (Array.isArray(docs)) {\n                    // TODO use a bulk operation instead of running .remove() on each document\n                    return Promise.all(docs.map(doc => doc.remove()));\n                } else {\n                    return (docs as any).remove();\n                }\n            });\n    }\n    incrementalRemove(): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.incrementalRemove(),\n        );\n    }\n\n\n    /**\n     * helper function to transform RxQueryBase to RxQuery type\n     */\n    get asRxQuery(): RxQuery<RxDocType, RxQueryResult> {\n        return this as any;\n    }\n\n    /**\n     * updates all found documents\n     * @overwritten by plugin (optional)\n     */\n    update(_updateObj: any): Promise<RxQueryResult> {\n        throw pluginMissing('update');\n    }\n\n    patch(patch: Partial<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.patch(patch),\n        );\n    }\n    incrementalPatch(patch: Partial<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.incrementalPatch(patch),\n        );\n    }\n    modify(mutationFunction: ModifyFunction<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.modify(mutationFunction),\n        );\n    }\n    incrementalModify(mutationFunction: ModifyFunction<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.incrementalModify(mutationFunction),\n        );\n    }\n\n\n    // we only set some methods of query-builder here\n    // because the others depend on these ones\n    where(_queryObj: MangoQuerySelector<RxDocType> | keyof RxDocType | string): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    sort(_params: string | MangoQuerySortPart<RxDocType>): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    skip(_amount: number | null): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    limit(_amount: number | null): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n\n    enableLimitBuffer(bufferSize: number) {\n        if (this._limitBufferSize !== null) {\n            // Limit buffer has already been enabled, do nothing:\n            return this;\n        }\n        if (this._lastExecStart !== 0) {\n            console.error('Can\\'t use limit buffer if query has already executed');\n            return this;\n        }\n        if (this.mangoQuery.skip || !this.mangoQuery.limit) {\n            console.error('Right now, limit buffer only works on non-skip, limit queries.');\n            return this;\n        }\n        this._limitBufferSize = bufferSize;\n        return this;\n    }\n\n    enablePersistentQueryCache(backend: QueryCacheBackend) {\n        if (this._persistentQueryCacheBackend) {\n            // We've already tried to enable the query cache\n            return this;\n        }\n        this._persistentQueryCacheBackend = backend;\n        this._persistentQueryCacheLoaded = this._restoreQueryCacheFromPersistedState();\n        return this;\n    }\n\n    private async _restoreQueryCacheFromPersistedState() {\n        if (!this._persistentQueryCacheBackend) {\n            // no cache backend provided, do nothing\n            return;\n        }\n        if (this._persistentQueryCacheResult) {\n            // we already restored the cache once, no need to run twice\n            return;\n        }\n        if (this.mangoQuery.skip || this.op === 'count') {\n            console.error('The persistent query cache only works on non-skip, non-count queries.');\n            return;\n        }\n\n        // First, check if there are any query results persisted:\n        const persistentQueryId = this.persistentQueryId();\n        const value = await this._persistentQueryCacheBackend.getItem<string[] | string>(`qc:${persistentQueryId}`);\n        if (!value || !Array.isArray(value) || value.length === 0) {\n            // eslint-disable-next-line no-console\n            console.log(`no persistent query cache found in the backend, returning early ${this.toString()}`);\n            return;\n        }\n\n        // If there are persisted ids, create our two Sets of ids from the cache:\n        const persistedQueryCacheIds = new Set<string>();\n        const limitBufferIds = new Set<string>();\n\n        for (const id of value) {\n            if (id.startsWith('lb-')) {\n                limitBufferIds.add(id.replace('lb-', ''));\n            } else {\n                persistedQueryCacheIds.add(id);\n            }\n        }\n\n        // eslint-disable-next-line no-console\n        console.time(`Restoring persistent querycache ${this.toString()}`);\n\n        // Next, pull the lwt from the cache:\n        // TODO: if lwt is too old, should we just give up here? What if there are too many changedDocs?\n        const lwt = (await this._persistentQueryCacheBackend.getItem(`qc:${persistentQueryId}:lwt`)) as string | null;\n        if (!lwt) {\n            return;\n        }\n\n        // If the query was persisted too long ago, just re-execute it.\n        if (now() - Number(lwt) > RESTORE_QUERY_MAX_TIME_AGO) {\n            return;\n        }\n\n        const primaryPath = this.collection.schema.primaryPath;\n\n        const {documents: changedDocs} = await getChangedDocumentsSince(this.collection.storageInstance,\n          RESTORE_QUERY_MAX_DOCS_CHANGED,\n          // make sure we remove the monotonic clock (xxx.01, xxx.02) from the lwt timestamp to avoid issues with\n          // lookups in indices (dexie)\n          {id: '', lwt: Math.floor(Number(lwt)) - RESTORE_QUERY_UPDATE_DRIFT}\n        );\n\n        // If too many docs have changed, just give up and re-execute the query\n        if (changedDocs.length === RESTORE_QUERY_MAX_DOCS_CHANGED) {\n            return;\n        }\n\n        const changedDocIds = new Set<string>(changedDocs.map((d) => d[primaryPath] as string));\n\n        const docIdsWeNeedToFetch = [...persistedQueryCacheIds, ...limitBufferIds].filter((id) => !changedDocIds.has(id));\n\n        // We use _queryCollectionByIds to fetch the remaining docs we need efficiently, pulling\n        // from query cache if we can (and the storageInstance by ids if we can't):\n        const otherPotentialMatchingDocs: RxDocumentData<RxDocType>[] = [];\n        await _queryCollectionByIds(this as any, otherPotentialMatchingDocs, docIdsWeNeedToFetch);\n\n        // Now that we have all potential documents, we just filter (in-memory) the ones that still match our query:\n        let docsData: RxDocumentData<RxDocType>[] = [];\n        for (const doc of changedDocs.concat(otherPotentialMatchingDocs)) {\n            if (this.doesDocumentDataMatch(doc)) {\n                docsData.push(doc);\n            }\n        }\n\n        // Sort the documents by the query's sort field:\n        const normalizedMangoQuery = normalizeMangoQuery<RxDocType>(\n          this.collection.schema.jsonSchema,\n          this.mangoQuery\n        );\n        const sortComparator = getSortComparator(this.collection.schema.jsonSchema, normalizedMangoQuery);\n        const limit = normalizedMangoQuery.limit ? normalizedMangoQuery.limit : Infinity;\n        docsData = docsData.sort(sortComparator);\n\n        // We know for sure that all persisted and limit buffer ids (and changed docs before them) are in the correct\n        // result set. And we can't be sure about any past that point. So cut it off there:\n        const lastValidIndex = docsData.findLastIndex((d) => limitBufferIds.has(d[primaryPath] as string) || persistedQueryCacheIds.has(d[primaryPath] as string));\n        docsData = docsData.slice(0, lastValidIndex + 1);\n\n        // Now this is the trickiest part.\n        // If we somehow have fewer docs than the limit of our query\n        // (and this wasn't the case because before persistence)\n        // then there is no way for us to know the correct results, and we re-exec:\n        const unchangedItemsMayNowBeInResults = (\n            this.mangoQuery.limit &&\n            docsData.length < this.mangoQuery.limit &&\n            persistedQueryCacheIds.size >= this.mangoQuery.limit\n        );\n        if (unchangedItemsMayNowBeInResults) {\n            return;\n        }\n\n        // Our finalResults are the actual results of this query, and pastLimitItems are any remaining matching\n        // documents we have left over (past the limit).\n        const pastLimitItems = docsData.slice(limit);\n        const finalResults = docsData.slice(0, limit);\n\n        // If there are still items past the first LIMIT items, try to restore the limit buffer with them:\n        if (limitBufferIds.size && pastLimitItems.length > 0) {\n            this._limitBufferResults = pastLimitItems;\n        } else {\n            this._limitBufferResults = [];\n        }\n\n        // Finally, set the query's results to what we've pulled from disk:\n        this._lastEnsureEqual = now();\n        this._latestChangeEvent = this.collection._changeEventBuffer.counter;\n        this._setResultData(finalResults);\n\n        // eslint-disable-next-line no-console\n        console.timeEnd(`Restoring persistent querycache ${this.toString()}`);\n    }\n}\n\nexport function _getDefaultQuery<RxDocType>(): MangoQuery<RxDocType> {\n    return {\n        selector: {}\n    };\n}\n\n/**\n * run this query through the QueryCache\n */\nexport function tunnelQueryCache<RxDocumentType, RxQueryResult>(\n    rxQuery: RxQueryBase<RxDocumentType, RxQueryResult>\n): RxQuery<RxDocumentType, RxQueryResult> {\n    return rxQuery.collection._queryCache.getByQuery(rxQuery as any);\n}\n\nexport function createRxQuery<RxDocType>(\n    op: RxQueryOP,\n    queryObj: MangoQuery<RxDocType>,\n    collection: RxCollection<RxDocType>,\n    other?: any\n) {\n    runPluginHooks('preCreateRxQuery', {\n        op,\n        queryObj,\n        collection,\n        other\n    });\n\n    let ret = new RxQueryBase<RxDocType, any>(op, queryObj, collection, other);\n\n    // ensure when created with same params, only one is created\n    ret = tunnelQueryCache(ret);\n    // TODO: clear persistent query cache as well\n    triggerCacheReplacement(collection);\n\n    return ret;\n}\n\n/**\n * Check if the current results-state is in sync with the database\n * which means that no write event happened since the last run.\n * @return false if not which means it should re-execute\n */\nfunction _isResultsInSync(rxQuery: RxQueryBase<any, any>): boolean {\n    const currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\n    if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n * @return true if has changed, false if not\n */\nfunction _ensureEqual(rxQuery: RxQueryBase<any, any>): Promise<boolean> {\n    // Optimisation shortcut\n    if (\n        rxQuery.collection.database.destroyed ||\n        _isResultsInSync(rxQuery)\n    ) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n\n    rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue\n        .then(() => __ensureEqual(rxQuery));\n    return rxQuery._ensureEqualQueue;\n}\n\n\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return true if results have changed\n */\nasync function __ensureEqual<RxDocType>(rxQuery: RxQueryBase<RxDocType, any>): Promise<boolean> {\n    await rxQuery._persistentQueryCacheLoaded;\n\n    rxQuery._lastEnsureEqual = now();\n\n    /**\n     * Optimisation shortcuts\n     */\n    if (\n        // db is closed\n        rxQuery.collection.database.destroyed ||\n        // nothing happened since last run\n        _isResultsInSync(rxQuery)\n    ) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n\n    let ret = false;\n    let mustReExec = false; // if this becomes true, a whole execution over the database is made\n    if (rxQuery._latestChangeEvent === -1) {\n        // have not executed yet -> must run\n        mustReExec = true;\n    }\n\n    /**\n     * try to use EventReduce to calculate the new results\n     */\n    if (!mustReExec) {\n        const missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n        if (missedChangeEvents === null) {\n            // changeEventBuffer is of bounds -> we must re-execute over the database\n            mustReExec = true;\n        } else {\n            rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\n\n            const runChangeEvents: RxChangeEvent<RxDocType>[] = rxQuery.asRxQuery.collection\n                ._changeEventBuffer\n                .reduceByLastOfDoc(missedChangeEvents);\n\n            if (rxQuery._limitBufferResults !== null) {\n                // Check if any item in our limit buffer was modified by a change event\n                for (const cE of runChangeEvents) {\n                    if (rxQuery._limitBufferResults.find((doc) => doc[rxQuery.collection.schema.primaryPath] === cE.documentId)) {\n                        // If so, the limit buffer is potential invalid -- let's just blow it up\n                        // TODO: could we instead update the documents in the limit buffer?\n                        rxQuery._limitBufferResults = null;\n                        break;\n                    }\n                }\n            }\n\n            if (rxQuery.includesDeleted) {\n                return rxQuery._execOverDatabase().then((newResultData) => {\n                    rxQuery._setResultData(newResultData);\n                    return true;\n                });\n            } else if (rxQuery.op === 'count') {\n                // 'count' query\n                const previousCount = ensureNotFalsy(rxQuery._result).count;\n                let newCount = previousCount;\n                runChangeEvents.forEach(cE => {\n                    const didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);\n                    const doesMatchNow = rxQuery.doesDocumentDataMatch(cE.documentData);\n\n                    if (!didMatchBefore && doesMatchNow) {\n                        newCount++;\n                    }\n                    if (didMatchBefore && !doesMatchNow) {\n                        newCount--;\n                    }\n                });\n                if (newCount !== previousCount) {\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(newCount as any);\n                }\n            } else {\n                // 'find' or 'findOne' query\n                const eventReduceResult = calculateNewResults(\n                    rxQuery as any,\n                    runChangeEvents\n                );\n                if (eventReduceResult.runFullQueryAgain) {\n                    // could not calculate the new results, execute must be done\n                    mustReExec = true;\n                } else if (eventReduceResult.changed) {\n                    // we got the new results, we do not have to re-execute, mustReExec stays false\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(eventReduceResult.newResults as any);\n                }\n            }\n        }\n    }\n\n    // oh no we have to re-execute the whole query over the database\n    if (mustReExec) {\n        return rxQuery._execOverDatabase()\n            .then(newResultData => {\n\n                /**\n                 * The RxStorage is defined to always first emit events and then return\n                 * on bulkWrite() calls. So here we have to use the counter AFTER the execOverDatabase()\n                 * has been run, not the one from before.\n                 */\n                rxQuery._latestChangeEvent = rxQuery.collection._changeEventBuffer.getCounter();\n\n                // A count query needs a different has-changed check.\n                if (typeof newResultData === 'number') {\n                    if (\n                        !rxQuery._result ||\n                        newResultData !== rxQuery._result.count\n                    ) {\n                        ret = true;\n                        rxQuery._setResultData(newResultData as any);\n                    }\n                    return ret;\n                }\n                if (\n                    !rxQuery._result ||\n                    !areRxDocumentArraysEqual(\n                        rxQuery.collection.schema.primaryPath,\n                        newResultData,\n                        rxQuery._result.docsData\n                    )\n                ) {\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(newResultData as any);\n                }\n                return ret;\n            })\n            .then(async (returnValue) => {\n                await updatePersistentQueryCache(rxQuery);\n                return returnValue;\n            });\n    }\n\n    return ret; // true if results have changed\n}\n\n\nasync function updatePersistentQueryCache<RxDocType>(rxQuery: RxQueryBase<RxDocType, any>) {\n    if (!rxQuery._persistentQueryCacheBackend) {\n        return;\n    }\n\n    const backend = rxQuery._persistentQueryCacheBackend;\n\n    const key = rxQuery.persistentQueryId();\n\n    // update _persistedQueryCacheResult\n    rxQuery._persistentQueryCacheResult = rxQuery._result?.docsKeys ?? [];\n\n    const idsToPersist = [...rxQuery._persistentQueryCacheResult];\n    if (rxQuery._limitBufferResults) {\n        rxQuery._limitBufferResults.forEach((d) => {\n            idsToPersist.push(`lb-${d[rxQuery.collection.schema.primaryPath]}`);\n        });\n    }\n    // eslint-disable-next-line no-console\n    console.time(`Query persistence: persisting results of ${JSON.stringify(rxQuery.mangoQuery)}`);\n    // persist query cache\n    const lwt = rxQuery._result?.time ?? RX_META_LWT_MINIMUM;\n\n    await Promise.all([\n        backend.setItem(`qc:${String(key)}`, idsToPersist),\n        backend.setItem(`qc:${String(key)}:lwt`, lwt.toString()),\n    ]);\n\n    // eslint-disable-next-line no-console\n    console.timeEnd(`Query persistence: persisting results of ${JSON.stringify(rxQuery.mangoQuery)}`);\n}\n\n\n// Refactored out of `queryCollection`: modifies the docResults array to fill it with data\nasync function _queryCollectionByIds<RxDocType>(rxQuery: RxQuery<RxDocType> | RxQueryBase<RxDocType, any>, docResults: RxDocumentData<RxDocType>[], docIds: string[]) {\n    const collection = rxQuery.collection;\n    docIds = docIds.filter(docId => {\n        // first try to fill from docCache\n        const docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n        if (docData) {\n            if (!docData._deleted) {\n                docResults.push(docData);\n            }\n            return false;\n        } else {\n            return true;\n        }\n    });\n\n    // otherwise get from storage\n    if (docIds.length > 0) {\n        const docsMap = await collection.storageInstance.findDocumentsById(docIds, false);\n        Object.values(docsMap).forEach(docData => {\n            docResults.push(docData);\n        });\n    }\n}\n\n/**\n * @returns a format of the query that can be used with the storage\n * when calling RxStorageInstance().query()\n */\nexport function prepareQuery<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    mutateableQuery: FilledMangoQuery<RxDocType>\n): PreparedQuery<RxDocType> {\n    if (!mutateableQuery.sort) {\n        throw newRxError('SNH', {\n            query: mutateableQuery\n        });\n    }\n\n    /**\n     * Store the query plan together with the\n     * prepared query to save performance.\n     */\n    const queryPlan = getQueryPlan(\n        schema,\n        mutateableQuery\n    );\n\n    return {\n        query: mutateableQuery,\n        queryPlan\n    };\n}\n\n/**\n * Runs the query over the storage instance\n * of the collection.\n * Does some optimizations to ensure findById is used\n * when specific queries are used.\n */\nexport async function queryCollection<RxDocType>(\n    rxQuery: RxQuery<RxDocType> | RxQueryBase<RxDocType, any>\n): Promise<RxDocumentData<RxDocType>[]> {\n    await rxQuery._persistentQueryCacheLoaded;\n\n    let docs: RxDocumentData<RxDocType>[] = [];\n    const collection = rxQuery.collection;\n\n    /**\n     * Optimizations shortcut.\n     * If query is find-one-document-by-id,\n     * then we do not have to use the slow query() method\n     * but instead can use findDocumentsById()\n     */\n    if (rxQuery.isFindOneByIdQuery) {\n        if (Array.isArray(rxQuery.isFindOneByIdQuery)) {\n            let docIds = rxQuery.isFindOneByIdQuery;\n            docIds = docIds.filter(docId => {\n                // first try to fill from docCache\n                const docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n                if (docData) {\n                    if (!docData._deleted) {\n                        docs.push(docData);\n                    }\n                    return false;\n                } else {\n                    return true;\n                }\n            });\n            // otherwise get from storage\n            if (docIds.length > 0) {\n                const docsFromStorage = await collection.storageInstance.findDocumentsById(docIds, false);\n                appendToArray(docs, docsFromStorage);\n            }\n            await _queryCollectionByIds(rxQuery, docs, rxQuery.isFindOneByIdQuery);\n        } else {\n            const docId = rxQuery.isFindOneByIdQuery;\n\n            // first try to fill from docCache\n            let docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n            if (!docData) {\n                // otherwise get from storage\n                const fromStorageList = await collection.storageInstance.findDocumentsById([docId], false);\n                if (fromStorageList[0]) {\n                    docData = fromStorageList[0];\n                }\n            }\n            if (docData && !docData._deleted) {\n                docs.push(docData);\n            }\n        }\n    } else {\n        const preparedQuery = rxQuery.getPreparedQuery();\n        const queryResult = await collection.storageInstance.query(preparedQuery);\n        if (rxQuery._limitBufferSize !== null && rxQuery.mangoQuery.limit && queryResult.documents.length > rxQuery.mangoQuery.limit) {\n            // If there are more than query.limit results, we pull out our buffer items from the\n            // last rxQuery._limitBufferSize items of the results.\n            rxQuery._limitBufferResults = queryResult.documents.splice(rxQuery.mangoQuery.limit);\n        }\n        docs = queryResult.documents;\n    }\n    return docs;\n}\n\n/**\n * Returns true if the given query\n * selects exactly one document by its id.\n * Used to optimize performance because these kind of\n * queries do not have to run over an index and can use get-by-id instead.\n * Returns false if no query of that kind.\n * Returns the document id otherwise.\n */\nexport function isFindOneByIdQuery(\n    primaryPath: string,\n    query: MangoQuery<any>\n): false | string | string[] {\n    // must have exactly one operator which must be $eq || $in\n    if (\n        !query.skip &&\n        query.selector &&\n        Object.keys(query.selector).length === 1 &&\n        query.selector[primaryPath]\n    ) {\n        const value: any = query.selector[primaryPath];\n        if (typeof value === 'string') {\n            return value;\n        } else if (\n            Object.keys(value).length === 1 &&\n            typeof value.$eq === 'string'\n        ) {\n            return value.$eq;\n        }\n\n        // same with $in string arrays\n        if (\n            Object.keys(value).length === 1 &&\n            Array.isArray(value.$eq) &&\n            // must only contain strings\n            !(value.$eq as any[]).find(r => typeof r !== 'string')\n        ) {\n            return value.$eq;\n        }\n    }\n    return false;\n}\n\n\nexport function isRxQuery(obj: any): boolean {\n    return obj instanceof RxQueryBase;\n}\n"],"mappings":"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","ignoreList":[]}