{"version":3,"file":"rx-query.js","names":["_rxjs","require","_operators","_utils","_rxError","_hooks","_eventReduce","_queryCache","_rxQueryHelper","_queryCount","newQueryID","UPDATE_DRIFT","RxQueryBase","exports","op","mangoQuery","collection","other","id","_execOverDatabaseCount","_creationTime","now","_lastEnsureEqual","uncached","refCount$","BehaviorSubject","_result","_latestChangeEvent","_lastExecStart","_lastExecEnd","_limitBufferSize","_limitBufferResults","_persistentQueryCacheResult","undefined","_persistentQueryCacheResultLwt","_ensureEqualQueue","PROMISE_RESOLVE_FALSE","_getDefaultQuery","isFindOneByIdQuery","schema","primaryPath","_proto","prototype","_setResultData","newResultData","docsData","docsKeys","docsMap","Map","docsDataMap","count","docs","time","Array","from","values","map","docData","_docCache","getCachedRxDocument","doc","set","primary","_data","push","length","_execOverDatabase","Number","preparedQuery","getPreparedQuery","result","storageInstance","mode","database","allowSlowCount","newRxError","queryObj","ids","ensureNotFalsy","selector","$in","ret","mustBeQueried","forEach","getLatestDocumentDataIfExists","_deleted","findDocumentsById","Object","docsPromise","queryCollection","then","exec","throwIfMissing","name","query","_ensureEqual","firstValueFrom","$","toString","stringObj","sortObject","value","JSON","stringify","stringifyFilter","persistentQueryId","String","hashFunction","hookInput","rxQuery","normalizeMangoQuery","jsonSchema","limit","runPluginHooks","storage","statics","prepareQuery","doesDocumentDataMatch","queryMatcher","remove","isArray","Promise","all","update","_updateObj","pluginMissing","where","_queryObj","sort","_params","skip","_amount","enableLimitBuffer","bufferSize","console","error","enablePersistentQueryCache","backend","_persistentQueryCacheBackend","_persistentQueryCacheLoaded","_restoreQueryCacheFromPersistedState","getItem","lwt","persistedQueryCacheIds","Set","documents","changedDocs","getChangedDocumentsSince","Math","floor","changedDoc","delete","nonRestoredDocIds","docId","normalizedMangoQuery","sortComparator","getSortComparator","Infinity","skipPlusLimit","slice","_changeEventBuffer","counter","isInteger","_createClass2","default","key","get","_$","results$","pipe","filter","changeEvent","isLocal","startWith","mergeMap","shareReplay","RXJS_SHARE_REPLAY_DEFAULTS","distinctUntilChanged","prev","curr","useResult","merge","normalizedQuery","overwriteGetterForCaching","getQueryMatcher","tunnelQueryCache","getByQuery","createRxQuery","triggerCacheReplacement","_isResultsInSync","currentLatestEventNumber","asRxQuery","destroyed","__ensureEqual","mustReExec","missedChangeEvents","getFrom","runChangeEvents","reduceByLastOfDoc","_loop","cE","find","documentId","previousCount","newCount","didMatchBefore","previousDocumentData","doesMatchNow","documentData","updatePersistentQueryCache","eventReduceResult","calculateNewResults","runFullQueryAgain","changed","newResults","limitResultsRemoved","latestAfter","areRxDocumentArraysEqual","returnValue","isCount","RX_META_LWT_MINIMUM","setItem","timeEnd","_queryCollectionByIds","docResults","docIds","hasOwnProperty","queryResult","splice","keys","$eq","r","isRxQuery","obj"],"sources":["../../src/rx-query.ts"],"sourcesContent":["import {\n    BehaviorSubject,\n    firstValueFrom,\n    Observable,\n    merge\n} from 'rxjs';\nimport {\n    mergeMap,\n    filter,\n    map,\n    startWith,\n    distinctUntilChanged,\n    shareReplay\n} from 'rxjs/operators';\nimport {\n    areRxDocumentArraysEqual,\n    ensureNotFalsy,\n    now,\n    overwriteGetterForCaching,\n    pluginMissing,\n    PROMISE_RESOLVE_FALSE, RX_META_LWT_MINIMUM,\n    RXJS_SHARE_REPLAY_DEFAULTS,\n    sortObject,\n    stringifyFilter\n} from './plugins/utils';\nimport {\n    newRxError\n} from './rx-error';\nimport {\n    runPluginHooks\n} from './hooks';\nimport type {\n    MangoQuery,\n    MangoQuerySelector,\n    MangoQuerySortPart,\n    PreparedQuery,\n    QueryMatcher,\n    RxChangeEvent,\n    RxCollection,\n    RxDocument,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxQuery,\n    RxQueryOP\n} from './types';\nimport { calculateNewResults } from './event-reduce';\nimport { triggerCacheReplacement } from './query-cache';\nimport { getQueryMatcher, getSortComparator, normalizeMangoQuery } from './rx-query-helper';\n\nexport interface QueryCacheBackend {\n    getItem<T extends string | string[]>(key: string): Promise<T | null>;\n    setItem<T extends string | string[]>(key: string, value: T): Promise<T>;\n}\n\nlet _queryCount = 0;\nconst newQueryID = function (): number {\n    return ++_queryCount;\n};\n\n// allow changes to be 100ms older than the actual lwt value\nconst UPDATE_DRIFT = 100;\n\nexport class RxQueryBase<\n    RxDocType,\n    // TODO also pass DocMethods here\n    RxQueryResult = RxDocument<RxDocType>[] | RxDocument<RxDocType>\n> {\n\n    public id: number = newQueryID();\n\n    /**\n     * Some stats then are used for debugging and cache replacement policies\n     */\n    public _execOverDatabaseCount: number = 0;\n    public _creationTime = now();\n\n    // used in the query-cache to determine if the RxQuery can be cleaned up.\n    public _lastEnsureEqual = 0;\n\n    public uncached = false;\n\n    // used to count the subscribers to the query\n    public refCount$ = new BehaviorSubject(null);\n\n    public isFindOneByIdQuery: false | string | string[];\n\n\n    /**\n     * Contains the current result state\n     * or null if query has not run yet.\n     */\n    public _result: {\n        docsData: RxDocumentData<RxDocType>[];\n        // A key->document map, used in the event reduce optimization.\n        docsDataMap: Map<string, RxDocType>;\n        docsKeys: string[];\n        docsMap: Map<string, RxDocument<RxDocType>>;\n        docs: RxDocument<RxDocType>[];\n        count: number;\n        /**\n         * Time at which the current _result state was created.\n         * Used to determine if the result set has changed since X\n         * so that we do not emit the same result multiple times on subscription.\n         */\n        time: number;\n    } | null = null;\n\n\n    constructor(\n        public op: RxQueryOP,\n        public mangoQuery: Readonly<MangoQuery<RxDocType>>,\n        public collection: RxCollection<RxDocType>,\n        // used by some plugins\n        public other: any = {}\n    ) {\n        if (!mangoQuery) {\n            this.mangoQuery = _getDefaultQuery();\n        }\n\n        this.isFindOneByIdQuery = isFindOneByIdQuery(\n            this.collection.schema.primaryPath as string,\n            mangoQuery\n        );\n    }\n    get $(): BehaviorSubject<RxQueryResult> {\n        if (!this._$) {\n\n            const results$ = this.collection.$.pipe(\n                /**\n                 * Performance shortcut.\n                 * Changes to local documents are not relevant for the query.\n                 */\n                filter(changeEvent => !changeEvent.isLocal),\n                /**\n                 * Start once to ensure the querying also starts\n                 * when there where no changes.\n                 */\n                startWith(null),\n                // ensure query results are up to date.\n                mergeMap(() => _ensureEqual(this as any)),\n                // use the current result set, written by _ensureEqual().\n                map(() => this._result),\n                // do not run stuff above for each new subscriber, only once.\n                shareReplay(RXJS_SHARE_REPLAY_DEFAULTS),\n                // do not proceed if result set has not changed.\n                distinctUntilChanged((prev, curr) => {\n                    if (prev && prev.time === ensureNotFalsy(curr).time) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }),\n                filter(result => !!result),\n                /**\n                 * Map the result set to a single RxDocument or an array,\n                 * depending on query type\n                 */\n                map((result) => {\n                    const useResult = ensureNotFalsy(result);\n                    if (this.op === 'count') {\n                        return useResult.count;\n                    } else if (this.op === 'findOne') {\n                        // findOne()-queries emit RxDocument or null\n                        return useResult.docs.length === 0 ? null : useResult.docs[0];\n                    } else if (this.op === 'findByIds') {\n                        return useResult.docsMap;\n                    } else {\n                        // find()-queries emit RxDocument[]\n                        // Flat copy the array so it won't matter if the user modifies it.\n                        return useResult.docs.slice(0);\n                    }\n                })\n            );\n\n            this._$ = merge<any>(\n                results$,\n                /**\n                 * Also add the refCount$ to the query observable\n                 * to allow us to count the amount of subscribers.\n                 */\n                this.refCount$.pipe(\n                    filter(() => false)\n                )\n            );\n        }\n        return this._$ as any;\n    }\n\n\n    // stores the changeEvent-number of the last handled change-event\n    public _latestChangeEvent: -1 | number = -1;\n\n    // time stamps on when the last full exec over the database has run\n    // used to properly handle events that happen while the find-query is running\n    public _lastExecStart: number = 0;\n    public _lastExecEnd: number = 0;\n\n    // Fields used for the Limit Buffer when enabled:\n    public _limitBufferSize: number | null = null;\n    public _limitBufferResults: RxDocumentData<RxDocType>[] | null = null;\n\n    // Fields used for the persistent query cache when enabled:\n    public _persistentQueryCacheResult?: string[] | string = undefined;\n    public _persistentQueryCacheResultLwt?: string = undefined; // lwt = latest write time\n    public _persistentQueryCacheLoaded?: Promise<void>;\n    public _persistentQueryCacheBackend?: QueryCacheBackend;\n\n    /**\n     * ensures that the exec-runs\n     * are not run in parallel\n     */\n    public _ensureEqualQueue: Promise<boolean> = PROMISE_RESOLVE_FALSE;\n\n    /**\n     * Returns an observable that emits the results\n     * This should behave like an rxjs-BehaviorSubject which means:\n     * - Emit the current result-set on subscribe\n     * - Emit the new result-set when an RxChangeEvent comes in\n     * - Do not emit anything before the first result-set was created (no null)\n     */\n    public _$?: Observable<RxQueryResult>;\n\n    /**\n     * set the new result-data as result-docs of the query\n     * @param newResultData json-docs that were received from the storage\n     */\n    _setResultData(newResultData: RxDocumentData<RxDocType>[] | number | Map<string, RxDocumentData<RxDocType>>): void {\n        if (typeof newResultData === 'number') {\n            this._result = {\n                docsData: [],\n                docsKeys: [],\n                docsMap: new Map(),\n                docsDataMap: new Map(),\n                count: newResultData,\n                docs: [],\n                time: now()\n            };\n            return;\n        } else if (newResultData instanceof Map) {\n            newResultData = Array.from((newResultData as Map<string, RxDocumentData<RxDocType>>).values());\n        }\n\n        const docsDataMap = new Map();\n        const docsMap = new Map();\n\n\n        const docs = newResultData.map(docData => this.collection._docCache.getCachedRxDocument(docData));\n\n        /**\n         * Instead of using the newResultData in the result cache,\n         * we directly use the objects that are stored in the RxDocument\n         * to ensure we do not store the same data twice and fill up the memory.\n         */\n        const docsKeys: string[] = [];\n        const docsData = docs.map(doc => {\n            docsDataMap.set(doc.primary, doc._data);\n            docsMap.set(doc.primary, doc);\n            docsKeys.push(doc.primary);\n            return doc._data;\n        });\n\n        this._result = {\n            docsData,\n            docsKeys,\n            docsMap,\n            docsDataMap,\n            count: docsData.length,\n            docs,\n            time: now()\n        };\n    }\n\n    /**\n     * executes the query on the database\n     * @return results-array with document-data\n     */\n    async _execOverDatabase(): Promise<RxDocumentData<RxDocType>[] | number> {\n        this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n        this._lastExecStart = now();\n\n\n        if (this.op === 'count') {\n            // if we have a persisted query cache result, use the result\n            if (this._persistentQueryCacheResult) {\n                // TODO: correct this number, but how?\n                return Number(this._persistentQueryCacheResult);\n            }\n\n            const preparedQuery = this.getPreparedQuery();\n            const result = await this.collection.storageInstance.count(preparedQuery);\n            if (result.mode === 'slow' && !this.collection.database.allowSlowCount) {\n                throw newRxError('QU14', {\n                    collection: this.collection,\n                    queryObj: this.mangoQuery\n                });\n            } else {\n                return result.count;\n            }\n        }\n\n        if (this.op === 'findByIds') {\n            const ids: string[] = ensureNotFalsy(this.mangoQuery.selector as any)[this.collection.schema.primaryPath].$in;\n            const ret = new Map<string, RxDocument<RxDocType>>();\n            const mustBeQueried: string[] = [];\n            // first try to fill from docCache\n            ids.forEach(id => {\n                const docData = this.collection._docCache.getLatestDocumentDataIfExists(id);\n                if (docData) {\n                    if (!docData._deleted) {\n                        const doc = this.collection._docCache.getCachedRxDocument(docData);\n                        ret.set(id, doc);\n                    }\n                } else {\n                    mustBeQueried.push(id);\n                }\n            });\n            // everything which was not in docCache must be fetched from the storage\n            if (mustBeQueried.length > 0) {\n                const docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);\n                Object.values(docs).forEach(docData => {\n                    const doc = this.collection._docCache.getCachedRxDocument(docData);\n                    ret.set(doc.primary, doc);\n                });\n            }\n            return ret as any;\n        }\n\n\n        const docsPromise = queryCollection<RxDocType>(this as any);\n        return docsPromise.then(docs => {\n            this._lastExecEnd = now();\n            return docs;\n        });\n    }\n\n    /**\n     * Execute the query\n     * To have an easier implementations,\n     * just subscribe and use the first result\n     */\n    public exec(throwIfMissing: true): Promise<RxDocument<RxDocType>>;\n    public exec(): Promise<RxQueryResult>;\n    public exec(throwIfMissing?: boolean): Promise<any> {\n        if (throwIfMissing && this.op !== 'findOne') {\n            throw newRxError('QU9', {\n                collection: this.collection.name,\n                query: this.mangoQuery,\n                op: this.op\n            });\n        }\n\n\n        /**\n         * run _ensureEqual() here,\n         * this will make sure that errors in the query which throw inside of the RxStorage,\n         * will be thrown at this execution context and not in the background.\n         */\n        return _ensureEqual(this)\n            .then(() => firstValueFrom(this.$))\n            .then(result => {\n                if (!result && throwIfMissing) {\n                    throw newRxError('QU10', {\n                        collection: this.collection.name,\n                        query: this.mangoQuery,\n                        op: this.op\n                    });\n                } else {\n                    return result;\n                }\n            });\n    }\n\n\n\n    /**\n     * cached call to get the queryMatcher\n     * @overwrites itself with the actual value\n     */\n    get queryMatcher(): QueryMatcher<RxDocumentWriteData<RxDocType>> {\n        const schema = this.collection.schema.jsonSchema;\n        const normalizedQuery = normalizeMangoQuery(\n            this.collection.schema.jsonSchema,\n            this.mangoQuery\n        );\n        return overwriteGetterForCaching(\n            this,\n            'queryMatcher',\n            getQueryMatcher(\n                schema,\n                normalizedQuery\n            ) as any\n        );\n    }\n\n    /**\n     * returns a string that is used for equal-comparisons\n     * @overwrites itself with the actual value\n     */\n    toString(): string {\n        const stringObj = sortObject({\n            op: this.op,\n            query: this.mangoQuery,\n            other: this.other\n        }, true);\n        const value = JSON.stringify(stringObj, stringifyFilter);\n        this.toString = () => value;\n        return value;\n    }\n\n    persistentQueryId() {\n        return String(this.collection.database.hashFunction(this.toString()));\n    }\n\n    /**\n     * returns the prepared query\n     * which can be send to the storage instance to query for documents.\n     * @overwrites itself with the actual value.\n     */\n    getPreparedQuery(): PreparedQuery<RxDocType> {\n        const hookInput = {\n            rxQuery: this,\n            // can be mutated by the hooks so we have to deep clone first.\n            mangoQuery: normalizeMangoQuery<RxDocType>(\n                this.collection.schema.jsonSchema,\n                this.mangoQuery\n            )\n        };\n\n        if (this._limitBufferSize !== null && hookInput.mangoQuery.limit) {\n            hookInput.mangoQuery.limit = hookInput.mangoQuery.limit + this._limitBufferSize;\n        }\n\n        runPluginHooks('prePrepareQuery', hookInput);\n\n        const value = this.collection.database.storage.statics.prepareQuery(\n            this.collection.schema.jsonSchema,\n            hookInput.mangoQuery\n        );\n\n        this.getPreparedQuery = () => value;\n        return value;\n    }\n\n    /**\n     * returns true if the document matches the query,\n     * does not use the 'skip' and 'limit'\n     */\n    doesDocumentDataMatch(docData: RxDocType | any): boolean {\n        // if doc is deleted, it cannot match\n        if (docData._deleted) {\n            return false;\n        }\n\n        return this.queryMatcher(docData);\n    }\n\n    /**\n     * deletes all found documents\n     * @return promise with deleted documents\n     */\n    remove(): Promise<RxQueryResult> {\n        return this\n            .exec()\n            .then(docs => {\n                if (Array.isArray(docs)) {\n                    // TODO use a bulk operation instead of running .remove() on each document\n                    return Promise.all(docs.map(doc => doc.remove()));\n                } else {\n                    return (docs as any).remove();\n                }\n            });\n    }\n\n\n    /**\n     * helper function to transform RxQueryBase to RxQuery type\n     */\n    get asRxQuery(): RxQuery<RxDocType, RxQueryResult> {\n        return this as any;\n    }\n\n    /**\n     * updates all found documents\n     * @overwritten by plugin (optional)\n     */\n    update(_updateObj: any): Promise<RxQueryResult> {\n        throw pluginMissing('update');\n    }\n\n\n    // we only set some methods of query-builder here\n    // because the others depend on these ones\n    where(_queryObj: MangoQuerySelector<RxDocType> | keyof RxDocType | string): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    sort(_params: string | MangoQuerySortPart<RxDocType>): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    skip(_amount: number | null): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    limit(_amount: number | null): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n\n    enableLimitBuffer(bufferSize: number) {\n        if (this._limitBufferSize !== null) {\n            // Limit buffer has already been enabled, do nothing:\n            return this;\n        }\n        if (this._lastExecStart !== 0) {\n            console.error('Can\\'t use limit buffer if query has already executed');\n            return this;\n        }\n        if (this.mangoQuery.skip || !this.mangoQuery.limit) {\n            console.error('Right now, limit buffer only works on non-skip, limit queries.');\n            return this;\n        }\n        this._limitBufferSize = bufferSize;\n        return this;\n    }\n\n    enablePersistentQueryCache(backend: QueryCacheBackend) {\n        this._persistentQueryCacheBackend = backend;\n        this._persistentQueryCacheLoaded = this._restoreQueryCacheFromPersistedState();\n        return this;\n    }\n\n    private async _restoreQueryCacheFromPersistedState() {\n        if (!this._persistentQueryCacheBackend) {\n            // no cache backend provided, do nothing\n            return;\n        }\n\n        if (this._persistentQueryCacheResult) {\n            // we already restored the cache once, no need to run twice\n            return;\n        }\n\n        if (this.mangoQuery.skip) {\n            console.error('The persistent query cache only works on non-skip queries.');\n            return;\n        }\n\n        const persistentQueryId = this.persistentQueryId();\n        const value = await this._persistentQueryCacheBackend.getItem<string[] | string>(`qc:${persistentQueryId}`);\n        if (!value) {\n          return;\n        }\n\n        const lwt = (await this._persistentQueryCacheBackend.getItem(`qc:${persistentQueryId}:lwt`)) as string | null;\n        const primaryPath = this.collection.schema.primaryPath;\n\n        this._persistentQueryCacheResult = value ?? undefined;\n        this._persistentQueryCacheResultLwt = lwt ?? undefined;\n\n        // if this is a regular query, also load documents into cache\n        if (Array.isArray(value) && value.length > 0) {\n            const persistedQueryCacheIds = new Set(this._persistentQueryCacheResult);\n\n            let docsData: RxDocumentData<RxDocType>[] = [];\n\n            // query all docs updated > last persisted, limit to an arbitrary 1_000_000 (10x of what we consider our largest library)\n            const {documents: changedDocs} = await this.collection.storageInstance.getChangedDocumentsSince(\n              1_000_000,\n              // make sure we remove the monotonic clock (xxx.01, xxx.02) from the lwt timestamp to avoid issues with\n              // lookups in indices (dexie)\n              {id: '', lwt: Math.floor(Number(lwt)) - UPDATE_DRIFT}\n            );\n\n            for (const changedDoc of changedDocs) {\n              /*\n               * no need to fetch again, we already got the doc from the list of changed docs, and therefore we filter\n               * deleted docs as well\n               */\n              persistedQueryCacheIds.delete(changedDoc[primaryPath] as string);\n\n              // ignore deleted docs or docs that do not match the query\n              if (!this.doesDocumentDataMatch(changedDoc)) {\n                continue;\n              }\n\n              // add to document cache\n              this.collection._docCache.getCachedRxDocument(changedDoc);\n\n              // add to docs\n              docsData.push(changedDoc);\n            }\n\n            // fetch remaining persisted doc ids\n            const nonRestoredDocIds: string[] = [];\n            for (const docId of persistedQueryCacheIds) {\n                // first try to fill from docCache\n                const docData = this.collection._docCache.getLatestDocumentDataIfExists(docId);\n                if (docData && this.doesDocumentDataMatch(docData)) {\n                  docsData.push(docData);\n                }\n\n                if (!docData) {\n                  nonRestoredDocIds.push(docId);\n                }\n            }\n\n            // otherwise get from storage\n            if (nonRestoredDocIds.length > 0) {\n              const docsMap = await this.collection.storageInstance.findDocumentsById(nonRestoredDocIds, false);\n              Object.values(docsMap).forEach(docData => {\n                this.collection._docCache.getCachedRxDocument(docData);\n                docsData.push(docData);\n              });\n            }\n\n            const normalizedMangoQuery = normalizeMangoQuery<RxDocType>(\n              this.collection.schema.jsonSchema,\n              this.mangoQuery\n            );\n            const sortComparator = getSortComparator(this.collection.schema.jsonSchema, normalizedMangoQuery);\n            const skip = normalizedMangoQuery.skip ? normalizedMangoQuery.skip : 0;\n            const limit = normalizedMangoQuery.limit ? normalizedMangoQuery.limit : Infinity;\n            const skipPlusLimit = skip + limit;\n            docsData = docsData.sort(sortComparator);\n            docsData = docsData.slice(skip, skipPlusLimit);\n\n\n            // get query into the correct state\n            this._lastEnsureEqual = now();\n            this._latestChangeEvent = this.collection._changeEventBuffer.counter;\n            this._setResultData(docsData);\n        } else if (value && Number.isInteger(Number(value))) {\n            // get query into the correct state\n            this._lastEnsureEqual = now();\n            this._latestChangeEvent = this.collection._changeEventBuffer.counter;\n            this._setResultData(Number(value));\n        }\n    }\n}\n\nexport function _getDefaultQuery<RxDocType>(): MangoQuery<RxDocType> {\n    return {\n        selector: {}\n    };\n}\n\n/**\n * run this query through the QueryCache\n */\nexport function tunnelQueryCache<RxDocumentType, RxQueryResult>(\n    rxQuery: RxQueryBase<RxDocumentType, RxQueryResult>\n): RxQuery<RxDocumentType, RxQueryResult> {\n    return rxQuery.collection._queryCache.getByQuery(rxQuery as any);\n}\n\nexport function createRxQuery<RxDocType>(\n    op: RxQueryOP,\n    queryObj: MangoQuery<RxDocType>,\n    collection: RxCollection<RxDocType>,\n    other?: any\n) {\n    runPluginHooks('preCreateRxQuery', {\n        op,\n        queryObj,\n        collection,\n        other\n    });\n\n    let ret = new RxQueryBase<RxDocType>(op, queryObj, collection, other);\n\n    // ensure when created with same params, only one is created\n    ret = tunnelQueryCache(ret);\n    // TODO: clear persistent query cache as well\n    triggerCacheReplacement(collection);\n\n    return ret;\n}\n\n/**\n * Check if the current results-state is in sync with the database\n * which means that no write event happened since the last run.\n * @return false if not which means it should re-execute\n */\nfunction _isResultsInSync(rxQuery: RxQueryBase<any>): boolean {\n    const currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.counter;\n    if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n * @return true if has changed, false if not\n */\nfunction _ensureEqual(rxQuery: RxQueryBase<any>): Promise<boolean> {\n    // Optimisation shortcut\n    if (\n        rxQuery.collection.database.destroyed ||\n        _isResultsInSync(rxQuery)\n    ) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n\n    rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue\n        .then(() => __ensureEqual(rxQuery));\n    return rxQuery._ensureEqualQueue;\n}\n\n\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return true if results have changed\n */\nasync function __ensureEqual<RxDocType>(rxQuery: RxQueryBase<RxDocType>): Promise<boolean> {\n    await rxQuery._persistentQueryCacheLoaded;\n\n    rxQuery._lastEnsureEqual = now();\n\n    /**\n     * Optimisation shortcuts\n     */\n    if (\n        // db is closed\n        rxQuery.collection.database.destroyed ||\n        // nothing happened since last run\n        _isResultsInSync(rxQuery)\n    ) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n\n    let ret = false;\n    let mustReExec = false; // if this becomes true, a whole execution over the database is made\n    if (rxQuery._latestChangeEvent === -1) {\n        // have not executed yet -> must run\n        mustReExec = true;\n    }\n\n    /**\n     * try to use EventReduce to calculate the new results\n     */\n    if (!mustReExec) {\n        const missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n        if (missedChangeEvents === null) {\n            // changeEventBuffer is of bounds -> we must re-execute over the database\n            mustReExec = true;\n        } else {\n            rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.counter;\n\n            const runChangeEvents: RxChangeEvent<any>[] = rxQuery.asRxQuery.collection\n                ._changeEventBuffer\n                .reduceByLastOfDoc(missedChangeEvents);\n\n            if (rxQuery._limitBufferResults !== null) {\n                // Check if any item in our limit buffer was modified by a change event\n                for (const cE of runChangeEvents) {\n                    if (rxQuery._limitBufferResults.find((doc) => doc[rxQuery.collection.schema.primaryPath] === cE.documentId)) {\n                        // If so, the limit buffer is potential invalid -- let's just blow it up\n                        // TODO: could we instead update the documents in the limit buffer?\n                        rxQuery._limitBufferResults = null;\n                        break;\n                    }\n                }\n            }\n\n            if (rxQuery.op === 'count') {\n                // 'count' query\n                const previousCount = ensureNotFalsy(rxQuery._result).count;\n                let newCount = previousCount;\n                runChangeEvents.forEach(cE => {\n                    const didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);\n                    const doesMatchNow = rxQuery.doesDocumentDataMatch(cE.documentData);\n\n                    if (!didMatchBefore && doesMatchNow) {\n                        newCount++;\n                    }\n                    if (didMatchBefore && !doesMatchNow) {\n                        newCount--;\n                    }\n                });\n                if (newCount !== previousCount) {\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(newCount as any);\n                    await updatePersistentQueryCache(rxQuery);\n                }\n            } else {\n                // 'find' or 'findOne' query\n                const eventReduceResult = calculateNewResults(\n                    rxQuery as any,\n                    runChangeEvents\n                );\n                if (eventReduceResult.runFullQueryAgain) {\n                    // could not calculate the new results, execute must be done\n                    mustReExec = true;\n                } else if (eventReduceResult.changed) {\n                    // we got the new results, we do not have to re-execute, mustReExec stays false\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(eventReduceResult.newResults as any);\n\n                    /*\n                     * We usually want to persist the cache every time there is an update to the query to guarantee\n                     * correctness. Cache persistence has some \"cost\", and we therefore try to optimize the number of\n                     * writes.\n                     * So, if any item in the result set was removed, we re-persist the query.\n                    */\n                    if (rxQuery.mangoQuery.limit && eventReduceResult.limitResultsRemoved) {\n                      await updatePersistentQueryCache(rxQuery);\n                    }\n                }\n            }\n        }\n    }\n\n\n    // oh no we have to re-execute the whole query over the database\n    if (mustReExec) {\n        // counter can change while _execOverDatabase() is running so we save it here\n        const latestAfter: number = (rxQuery as any).collection._changeEventBuffer.counter;\n        return rxQuery._execOverDatabase()\n            .then(newResultData => {\n                rxQuery._latestChangeEvent = latestAfter;\n\n                // A count query needs a different has-changed check.\n                if (typeof newResultData === 'number') {\n                    if (\n                        !rxQuery._result ||\n                        newResultData !== rxQuery._result.count\n                    ) {\n                        ret = true;\n                        rxQuery._setResultData(newResultData as any);\n                    }\n                    return ret;\n                }\n                if (\n                    !rxQuery._result ||\n                    !areRxDocumentArraysEqual(\n                        rxQuery.collection.schema.primaryPath,\n                        newResultData,\n                        rxQuery._result.docsData\n                    )\n                ) {\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(newResultData as any);\n                }\n                return ret;\n            })\n            .then(async (returnValue) => {\n                await updatePersistentQueryCache(rxQuery);\n                return returnValue;\n            });\n    }\n\n    return ret; // true if results have changed\n}\n\n\nasync function updatePersistentQueryCache<RxDocType>(rxQuery: RxQueryBase<RxDocType>) {\n    if (!rxQuery._persistentQueryCacheBackend) {\n        return;\n    }\n\n    const backend = rxQuery._persistentQueryCacheBackend;\n\n    const isCount = rxQuery._result?.docs.length === 0 && rxQuery._result.count > 0;\n\n    const key = rxQuery.persistentQueryId();\n    const value = isCount\n        ? rxQuery._result?.count?.toString() ?? '0'\n        : rxQuery._result?.docsKeys ?? [];\n\n    // update _persistedQueryCacheResult\n    rxQuery._persistentQueryCacheResult = value;\n\n    // eslint-disable-next-line no-console\n    console.time(`Query persistence: persisting results of ${JSON.stringify(rxQuery.mangoQuery)}`);\n    // persist query cache\n    const lwt = rxQuery._result?.time ?? RX_META_LWT_MINIMUM;\n    await backend.setItem(`qc:${String(key)}`, value);\n    await backend.setItem(`qc:${String(key)}:lwt`, lwt.toString());\n\n    // eslint-disable-next-line no-console\n    console.timeEnd(`Query persistence: persisting results of ${JSON.stringify(rxQuery.mangoQuery)}`);\n}\n\n\n// Refactored out of `queryCollection`: modifies the docResults array to fill it with data\nasync function _queryCollectionByIds<RxDocType>(rxQuery: RxQuery<RxDocType> | RxQueryBase<RxDocType>, docResults: RxDocumentData<RxDocType>[], docIds: string[]) {\n    const collection = rxQuery.collection;\n    docIds = docIds.filter(docId => {\n        // first try to fill from docCache\n        const docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n        if (docData) {\n            if (!docData._deleted) {\n                docResults.push(docData);\n            }\n            return false;\n        } else {\n            return true;\n        }\n    });\n\n    // otherwise get from storage\n    if (docIds.length > 0) {\n        const docsMap = await collection.storageInstance.findDocumentsById(docIds, false);\n        Object.values(docsMap).forEach(docData => {\n            docResults.push(docData);\n        });\n    }\n}\n\n/**\n * Runs the query over the storage instance\n * of the collection.\n * Does some optimizations to ensure findById is used\n * when specific queries are used.\n */\nexport async function queryCollection<RxDocType>(\n    rxQuery: RxQuery<RxDocType> | RxQueryBase<RxDocType>\n): Promise<RxDocumentData<RxDocType>[]> {\n    await rxQuery._persistentQueryCacheLoaded;\n\n    let docs: RxDocumentData<RxDocType>[] = [];\n    const collection = rxQuery.collection;\n\n    /**\n     * Optimizations shortcut.\n     * If query is find-one-document-by-id,\n     * then we do not have to use the slow query() method\n     * but instead can use findDocumentsById()\n     */\n    if (rxQuery.isFindOneByIdQuery) {\n        if (Array.isArray(rxQuery.isFindOneByIdQuery)) {\n            await _queryCollectionByIds(rxQuery, docs, rxQuery.isFindOneByIdQuery);\n        } else {\n            const docId = rxQuery.isFindOneByIdQuery;\n\n            // first try to fill from docCache\n            let docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n            if (!docData) {\n                // otherwise get from storage\n                const docsMap = await collection.storageInstance.findDocumentsById([docId], false);\n                if (docsMap.hasOwnProperty(docId)) {\n                    docData = docsMap[docId];\n                }\n            }\n            if (docData && !docData._deleted) {\n                docs.push(docData);\n            }\n        }\n    } else {\n        const preparedQuery = rxQuery.getPreparedQuery();\n        const queryResult = await collection.storageInstance.query(preparedQuery);\n        if (rxQuery._limitBufferSize !== null && rxQuery.mangoQuery.limit && queryResult.documents.length > rxQuery.mangoQuery.limit) {\n            // If there are more than query.limit results, we pull out our buffer items from the\n            // last rxQuery._limitBufferSize items of the results.\n            rxQuery._limitBufferResults = queryResult.documents.splice(rxQuery.mangoQuery.limit);\n        }\n        docs = queryResult.documents;\n    }\n    return docs;\n}\n\n/**\n * Returns true if the given query\n * selects exactly one document by its id.\n * Used to optimize performance because these kind of\n * queries do not have to run over an index and can use get-by-id instead.\n * Returns false if no query of that kind.\n * Returns the document id otherwise.\n */\nexport function isFindOneByIdQuery(\n    primaryPath: string,\n    query: MangoQuery<any>\n): false | string | string[] {\n    // must have exactly one operator which must be $eq || $in\n    if (\n        !query.skip &&\n        query.selector &&\n        Object.keys(query.selector).length === 1 &&\n        query.selector[primaryPath]\n    ) {\n        const value: any = query.selector[primaryPath];\n        if (typeof value === 'string') {\n            return value;\n        } else if (\n            Object.keys(value).length === 1 &&\n            typeof value.$eq === 'string'\n        ) {\n            return value.$eq;\n        }\n\n        // same with $in string arrays\n        if (\n            Object.keys(value).length === 1 &&\n            Array.isArray(value.$eq) &&\n            // must only contain strings\n            !(value.$eq as any[]).find(r => typeof r !== 'string')\n        ) {\n            return value.$eq;\n        }\n    }\n    return false;\n}\n\n\nexport function isRxQuery(obj: any): boolean {\n    return obj instanceof RxQueryBase;\n}\n"],"mappings":"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"}